COMPILER Tastier // DMA

  public SymbolTable   tab;
  public CodeGenerator gen;
  int labelSeed;

  string generateLabel() {
    return "L" + labelSeed++;
  }

/*--------------------------------------------------------------------------*/

CHARACTERS
letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.

TOKENS
  ident  = letter {letter | digit}.
  number = digit {digit}.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

/*------------------------------------------------------------------------*/

AddOp<out InstructionWord inst>
=                        (. inst = new InstructionWord(Instruction.ADD); .)
  ( '+'
  | '-'                  (. inst = new InstructionWord(Instruction.SUB); .)
  ).

/*------------------------------------------------------------------------*/

Expr<out TType type>      (. TType type1; InstructionWord inst; .)
= SimExpr<out type>
  [ RelOp<out inst>
    SimExpr<out type1>   (. if (type != type1) { SemErr("incompatible types"); }
                            else { gen.Emit(inst); type = TType.Bool; } .)
  ].

/*------------------------------------------------------------------------*/

Factor<out TType type>    (. int n; Obj obj; string name; .)
=                        (. type = TType.Undefined; .)
  ( Ident<out name>      (. obj = tab.Find(name); type = obj.type;
                            if (obj.kind == Kind.Variable) {
                              if (obj.level == 0) {
                                if (obj.address.kind == AddressKind.Direct) {
                                  gen.Emit(new InstructionWord(Instruction.LOADG, obj.address.value_if_direct));
                                } else { SemErr("cannot LOADG from a label"); }
                              } else {
                                if (obj.address.kind == AddressKind.Direct) {
                                  gen.Emit(new InstructionWord(Instruction.LOAD, tab.currentLevel()-obj.level, obj.address.value_if_direct));
                                } else SemErr("cannot LOAD from a label");
                              }
                            } else SemErr("variable expected"); .)
  | number               (. n = Convert.ToInt32(t.val);
                            gen.Emit(new InstructionWord(Instruction.CONST, n)); type = TType.Integer; .)
  | '-'
    Factor<out type>     (. if (type != TType.Integer) {
                               SemErr("integer type expected"); type = TType.Integer;
                            }
                            gen.Emit(new InstructionWord(Instruction.NEG)); .)
  | "true"               (. gen.Emit(new InstructionWord(Instruction.CONST, 1)); type = TType.Bool; .)
  | "false"              (. gen.Emit(new InstructionWord(Instruction.CONST, 0)); type = TType.Bool; .)
  ).

/*------------------------------------------------------------------------*/

Ident<out string name>
= ident                  (. name = t.val; .).

/*------------------------------------------------------------------------*/

MulOp<out InstructionWord inst>
=                        (. inst = new InstructionWord(Instruction.MUL); .)
  ( '*'
  | '/'                  (. inst = new InstructionWord(Instruction.DIV); .)
  ).

/*------------------------------------------------------------------------*/

ProcDecl                 (. string name; Obj obj; int adr, adr2; .)         // DMA
= "void"
  Ident<out name>        (. obj = tab.NewObj(name, Kind.Procedure, TType.Undefined);
                            //obj.adr = gen.pc;

                            if (name == "Main") {                           // DMA
                               obj.level = 0;                               // DMA
                            } else { obj.level = tab.currentLevel()+1; }          // DMA
                            tab.OpenScope(); .)
  '(' ')'
  '{'                    (. gen.Emit(new InstructionWord(Instruction.ENTER, 0)); .)

  { VarDecl | Stat |     (. gen.Emit(new InstructionWord(Instruction.JMP, 0)); .)      // DMA
    ProcDecl             //(. gen.Patch(adr2, gen.pc); .)
  }                                                                         // DMA
  '}'                    (. gen.Emit(new InstructionWord(Instruction.LEAVE));
                            gen.Emit(new InstructionWord(Instruction.RET));
                            //gen.Patch(adr, tab.topScope.nextAdr);
                            tab.CloseScope(); .).

/*------------------------------------------------------------------------*/

RelOp<out InstructionWord inst>
=                        (. inst = new InstructionWord(Instruction.EQU); .)
  ( "=="
  | '<'                  (. inst = new InstructionWord(Instruction.LSS); .)
  | '>'                  (. inst = new InstructionWord(Instruction.GTR); .)
  ).

/*------------------------------------------------------------------------*/

SimExpr<out TType type>    (. TType type1; InstructionWord inst; .)
= Term<out type>
  { AddOp<out inst>
    Term<out type1>      (. if (type != TType.Integer || type1 != TType.Integer)
                               SemErr("integer type expected");
                            gen.Emit(inst); .)
  }.

/*------------------------------------------------------------------------*/

Stat                     (. TType type; string name; Obj obj;
                            int adr, adr2, loopstart; .)
= Ident<out name>        (. obj = tab.Find(name); .)
  ( '='                  (. if (obj.kind != Kind.Variable) SemErr("cannot assign to non-variable"); .)
    Expr<out type> ';'
                         (. if (type != obj.type) SemErr("incompatible types");
                            if (obj.level == 0) gen.Emit(new InstructionWord(Instruction.STOG, obj.address.value_if_direct));
                               else gen.Emit(new InstructionWord(Instruction.STO, tab.currentLevel()-obj.level, obj.address.value_if_direct)); .) // DMA
  | '(' ')' ';'          (. if (obj.kind != Kind.Procedure) SemErr("object is not a procedure");
                               gen.Emit(new InstructionWord(Instruction.CALL, obj.level-tab.currentLevel(), obj.address.value_if_direct)); .)     // DMA
  )

| "if"
  '(' Expr<out type> ')' (. if (type != TType.Bool) SemErr("boolean type expected");
                               gen.Emit(new InstructionWord(Instruction.FJMP, 0)); .)
      Stat
      [ "else"           (. gen.Emit(new InstructionWord(Instruction.JMP, 0));
                            //gen.Patch(adr, gen.pc); adr = adr2;
                          .)
        Stat
      ]                  (.
                            //gen.Patch(adr, gen.pc);
                          .)

| "while"                (. /*loopstart = gen.pc;*/ .)
  '(' Expr<out type> ')' (. if (type != TType.Bool) SemErr("boolean type expected");
                               gen.Emit(new InstructionWord(Instruction.FJMP, 0)); /*adr = gen.pc - 2;*/ .)
      Stat               (. gen.Emit(new InstructionWord(Instruction.JMP, 0)); /*gen.Patch(adr, gen.pc);*/ .)

| "read"
  Ident<out name> ';'    (. obj = tab.Find(name);
                            if (obj.type != TType.Integer) SemErr("integer type expected");
                               gen.Emit(new InstructionWord(Instruction.READ));
                            if (obj.level == 0) gen.Emit(new InstructionWord(Instruction.STOG, obj.address.value_if_direct));
                               else gen.Emit(new InstructionWord(Instruction.STO, tab.currentLevel()-obj.level, obj.address.value_if_direct)); .) // DMA

| "write"
  Expr<out type> ';'     (. if (type != TType.Integer) SemErr("integer type expected");
                               gen.Emit(new InstructionWord(Instruction.WRITE)); .)

| '{' { Stat | VarDecl } '}' .

/*------------------------------------------------------------------------*/

Tastier                  (. string name; .) // DMA
= "program"
  Ident<out name>        (. tab.OpenScope(); .)
  '{'
  { VarDecl | ProcDecl }
  '}'                    (. tab.CloseScope();
                            //if (gen.progStart == -1) SemErr("main function never defined");
                         .).

/*------------------------------------------------------------------------*/

Term<out TType type>       (. TType type1; InstructionWord inst; .)
= Factor<out type>
  { MulOp<out inst>
    Factor<out type1>    (. if (type != TType.Integer || type1 != TType.Integer)
                               SemErr("integer type expected");
                            gen.Emit(inst); .)
  }.

/*------------------------------------------------------------------------*/

Type<out TType type>
=                        (. type = TType.Undefined; .)
 ( "int"                 (. type = TType.Integer; .)
 | "bool"                (. type = TType.Bool; .)
 ).

/*------------------------------------------------------------------------*/

VarDecl                  (. string name; TType type; .)
= Type<out type>
  Ident<out name>        (. tab.NewObj(name, Kind.Variable, type); .)
  { ',' Ident<out name>  (. tab.NewObj(name, Kind.Variable, type); .)
  } ';'.

END Tastier. // DMA
