COMPILER Tastier // DMA

/*
  First, let's declare all the types we're going to use.
*/

  enum TastierType {   // types for variables
    Undefined,
    Integer,
    Boolean
  };

  enum TastierKind {  // kinds of symbol
    Var,
    Proc
  };

/*
  You'll notice some type aliases, such as the one just below, are commented
  out. This is because C# only allows using-alias-directives outside of a
  class, while class-inheritance directives are allowed inside. So the
  snippet immediately below is illegal in here. To complicate matters
  further, the C# runtime does not properly handle class-inheritance
  directives for Tuples (it forces you to write some useless methods). For
  these reasons, the type aliases which alias Tuples can be found in
  Parser.frame, but they're documented in this file, with the rest.
*/

  //using Symbol = System.Tuple<string, int, int>;

/*
  A Symbol is a name with a type and a kind. The first int in the tuple is
  the kind, and the second int is the type. We'll use these to represent
  declared names in the program. For each Symbol which is a variable, we
  have to allocate some storage, so the variable lives at some address in
  memory. Procedures, on the other hand, are just sets of instructions. A
  procedure is not data, so it isn't stored on the stack or in memory, but
  is just a particular part of the list of instructions in the program being
  compiled. When the program is being run, the code will be loaded into the
  machine's instruction memory, and the procedure will have an address
  there. However, it's easier for us to just give the procedure a unique
  label, instead of remembering what address it lives at. The assembler will
  take care of converting the label into an address when it encounters a
  JMP, FJMP or CALL instruction with that label as a target.
*/

  class Scope : Stack<Symbol> {}

/*
  A scope contains a stack of symbol definitions. Every time we come across
  a new local variable declaration, we can just push it onto the stack. We'll
  use the position of the variable in the stack to represent its address in
  the stack frame of the procedure in which it is defined. In other words, the
  variable at the bottom of the stack goes at location 0 in the stack frame,
  the next variable at location 1, and so on.
*/

  //using Instruction = Tuple<string, string>;
  class Program : List<Instruction> {}

/*
  A program is just a list of instructions. When the program is loaded into
  the machine's instruction memory, the instructions will be laid out in the
  same order that they appear in this list. Because of this, we can use the
  location of an instruction in the list as its address in instruction memory.
  Labels are just names for particular locations in the list of instructions
  that make up the program.

  The first component of all instructions is a label, which can be empty.
  The second component is the actual instruction itself.
*/

Stack<Scope> openScopes = new Stack<Scope>();

/*
  Every time we encounter a new procedure declaration in the program, we want
  to make sure that expressions inside the procedure see all of the variables
  that were in scope at the point where the procedure was defined. We also
  want to make sure that expressions outside the procedure do not see the
  procedure's local variables. Every time we encounter a procedure, we'll push
  a new scope on the stack of open scopes. When the procedure ends, we can pop
  it off and continue, knowing that the local variables defined in the
  procedure cannot be seen outside, since we've popped the scope which
  contains them off the stack.
*/

Program program = new Program();
Stack<string> openLabels = new Stack<string>();

/*
  Sometimes, we need to jump over a block of code which we're about to
  generate (for example, at the start of a loop, if the test fails, we have
  to jump to the end of the loop). Because it hasn't been generated yet, we
  don't know how long it will be (in the case of the loop, we don't know how
  many instructions will be in the loop body until we actually generate the
  code, and count them). In this case, we can make up a new label for "the
  end of the loop" and emit a jump to that label. When we get to the end of
  the loop, we can put the label in, so that the jump will go to the
  labelled location. Since we can have loops within loops, we need to keep
  track of which label is the one that we are currently trying to jump to,
  and we need to make sure they go in the right order. We'll use a stack to
  store the labels for all of the forward jumps which are active. Every time
  we need to do a forward jump, we'll generate a label, emit a jump to that
  label, and push it on the stack. When we get to the end of the loop, we'll
  put the label in, and pop it off the stack.
*/

  //using StackAddress = Tuple<int, int>;

/*
  The address of a variable on the stack at runtime has two components. The
  first component is which stack frame it's in, relative to the current
  procedure. If the variable is declared in the procedure that's currently
  executing, then it will be in that procedure's stack frame. If it's declared
  in the procedure that called the currently active one, then it'll be in the
  caller's stack frame, and so on. The first component is the offset that says
  how many frames up the chain of procedure calls to look for the variable.
  The second component is simply the location of the variable in the stack
  frame where it lives.
*/

Tuple<Symbol, StackAddress> lookup(Stack<Scope> scopes, string name) {
  int stackFrameOffset = 0;
  int variableOffset = 0;

  foreach (Scope scope in scopes) {
    foreach (Symbol s in scope) {
      if (s.Item1 == name) {
        StackAddress addr = new StackAddress(stackFrameOffset, variableOffset);
        return new Tuple<Symbol, StackAddress>(s, addr);
      }
      else {
        variableOffset += 1;
      }
    }
    stackFrameOffset += 1;
    variableOffset = 0;
  }
  return null; // if the name wasn't found in any open scopes.
}

/*--------------------------------------------------------------------------*/

CHARACTERS
letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.

TOKENS
  ident  = letter {letter | digit}.
  number = digit {digit}.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

/*------------------------------------------------------------------------*/

AddOp<out Instruction inst>
=                        (. inst = new Instruction("", "Add"); .)
  ( '+'
  | '-'                  (. inst = new Instruction("", "Sub"); .)
  ).

/*------------------------------------------------------------------------*/

Expr<out TastierType type>      (. TastierType type1; Instruction inst; .)
= SimExpr<out type>
  [ RelOp<out inst>
    SimExpr<out type1>   (. if (type != type1) { SemErr("incompatible types"); }
                            else { program.Add(inst); type = TastierType.Boolean; } .)
  ].

/*------------------------------------------------------------------------*/

Factor<out TastierType type>    (. int n; Tuple<Symbol, StackAddress> result; string name; .)
=                        (. type = TastierType.Undefined; .)
  ( Ident<out name>      (. result = lookup(openScopes, name);
                            if (result == null) { SemErr("reference to undefined variable " + name);}
                            else {
                              type = result.Item1.Item3;
                              if (result.Item1.Item2 == Kind.Var) {
                                if (result.Item2.Item1 == 0) {
                                    program.Add(new Instruction("", "LoadG " + result.Item2.Item2));
                                } else {
                                    program.Add(new Instruction("", "Load " + result.Item2.Item1 + " " + result.Item2.Item2));
                                }
                              } else SemErr("variable expected");
                            }.)
  | number               (. n = Convert.ToInt32(t.val);
                            program.Add(new Instruction("", "Const " + n));
                            type = TastierType.Integer; .)
  | '-'
    Factor<out type>     (. if (type != TastierType.Integer) {
                               SemErr("integer type expected");
                               type = TastierType.Integer;
                            }
                            program.Add(new Instruction("", "Neg")); .)
  | "true"               (. program.Add(new Instruction("", "Const " + 1)); type = TastierType.Boolean; .)
  | "false"              (. program.Add(new Instruction("", "Const " + 0)); type = TastierType.Boolean; .)
  ).

/*------------------------------------------------------------------------*/

Ident<out string name>
= ident                  (. name = t.val; .).

/*------------------------------------------------------------------------*/

MulOp<out Instruction inst>
=                        (. inst = new Instruction("", "Mul"); .)
  ( '*'
  | '/'                  (. inst = new Instruction("", "Div"); .)
  ).

/*------------------------------------------------------------------------*/

ProcDecl                 (. string name; Tuple<Symbol, StackAddress> result; .)         // DMA
= "void"
  Ident<out name>        (. openScopes.Peek().Push(new Symbol(name, Kind.Procedure, TastierType.Undefined));
                            openScopes.Push(new Scope());.)
  '(' ')'
  '{'                    (. program.Add(new Instruction(name, "Enter " + 0)); .)

  { VarDecl | Stat |     (. program.Add(new Instruction("", "Jmp " + name + "$end")); .)      // DMA
    ProcDecl
  }                                                                         // DMA
  '}'                    (. program.Add(new Instruction("", "Leave"));
                            program.Add(new Instruction("", "Ret"));
                            program.Add(new Instruction(name + "$end", "Nop"));
                            openScopes.Pop(); .).

/*------------------------------------------------------------------------*/

RelOp<out Instruction inst>
=                        (. inst = new Instruction("", "Equ"); .)
  ( "=="
  | '<'                  (. inst = new Instruction("", "Lss"); .)
  | '>'                  (. inst = new Instruction("", "Gtr"); .)
  ).

/*------------------------------------------------------------------------*/

SimExpr<out TastierType type>    (. TastierType type1; Instruction inst; .)
= Term<out type>
  { AddOp<out inst>
    Term<out type1>      (. if (type != TastierType.Integer || type1 != TastierType.Integer)
                               SemErr("integer type expected");
                            program.Add(inst); .)
  }.

/*------------------------------------------------------------------------*/

Stat                     (. TastierType type; string name; Tuple<Symbol, StackAddress> result; Symbol sym;
                            int adr, adr2, loopstart; .)
= Ident<out name>        (. result = lookup(openScopes, name);
                            if (result == null) { SemErr("reference to undefined variable " + name); }
                            else { sym = result.Item1; } .)
  ( '='                  (. if (sym.Item1 != Kind.Variable) SemErr("cannot assign to non-variable"); .)
    Expr<out type> ';'
                         (. if (type != (TastierType)sym.Item2) SemErr("incompatible types");
                            if (obj.level == 0) program.Add(new Instruction(Instruction.STOG, obj.address.value_if_direct));
                               else program.Add(new Instruction(Instruction.STO, tab.currentLevel()-obj.level, obj.address.value_if_direct)); .) // DMA
  | '(' ')' ';'          (. if (obj.kind != Kind.Procedure) SemErr("object is not a procedure");
                               program.Add(new Instruction(Instruction.CALL, obj.level-tab.currentLevel(), obj.address.value_if_direct)); .)     // DMA
  )

| "if"
  '(' Expr<out type> ')' (. if (type != TastierType.Boolean) SemErr("boolean type expected");
                               program.Add(new Instruction(Instruction.FJMP, 0)); .)
      Stat
      [ "else"           (. program.Add(new Instruction(Instruction.JMP, 0));
                            //gen.Patch(adr, gen.pc); adr = adr2;
                          .)
        Stat
      ]                  (.
                            //gen.Patch(adr, gen.pc);
                          .)

| "while"                (. /*loopstart = gen.pc;*/ .)
  '(' Expr<out type> ')' (. if (type != TastierType.Boolean) SemErr("boolean type expected");
                               program.Add(new Instruction(Instruction.FJMP, 0)); /*adr = gen.pc - 2;*/ .)
      Stat               (. program.Add(new Instruction(Instruction.JMP, 0)); /*gen.Patch(adr, gen.pc);*/ .)

| "read"
  Ident<out name> ';'    (. obj = tab.Find(name);
                            if (obj.type != TastierType.Integer) SemErr("integer type expected");
                               program.Add(new Instruction(Instruction.READ));
                            if (obj.level == 0) program.Add(new Instruction(Instruction.STOG, obj.address.value_if_direct));
                               else program.Add(new Instruction(Instruction.STO, tab.currentLevel()-obj.level, obj.address.value_if_direct)); .) // DMA

| "write"
  Expr<out type> ';'     (. if (type != TastierType.Integer) SemErr("integer type expected");
                               program.Add(new Instruction("", "Write")); .)

| '{' { Stat | VarDecl } '}' .

/*------------------------------------------------------------------------*/

Tastier                  (. string name; .) // DMA
= "program"
  Ident<out name>        (. openScopes.Push(new Scope()); .)
  '{'
  { VarDecl | ProcDecl }
  '}'                    (. if (openScopes.Peek().Count == 0) { SemErr("No main function defined"); }
                            openScopes.Pop(); .).

/*------------------------------------------------------------------------*/

Term<out TastierType type>       (. TastierType type1; Instruction inst; .)
= Factor<out type>
  { MulOp<out inst>
    Factor<out type1>    (. if (type != TastierType.Integer || type1 != TastierType.Integer)
                               SemErr("integer type expected");
                            program.Add(inst); .)
  }.

/*------------------------------------------------------------------------*/

Type<out TastierType type>
=                        (. type = TastierType.Undefined; .)
 ( "int"                 (. type = TastierType.Integer; .)
 | "bool"                (. type = TastierType.Boolean; .)
 ).

/*------------------------------------------------------------------------*/

VarDecl                  (. string name; TastierType type; .)
= Type<out type>
  Ident<out name>        (. openScopes.Peek().Push(new Symbol(name, Kind.Variable, type)); .)
  { ',' Ident<out name>  (. openScopes.Peek().Push(new Symbol(name, Kind.Variable, type)); .)
  } ';'.

END Tastier. // DMA
